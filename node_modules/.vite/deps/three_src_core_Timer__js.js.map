{
  "version": 3,
  "sources": ["../../three/src/core/Timer.js"],
  "sourcesContent": ["/**\n * This class is an alternative to {@link Clock} with a different API design and behavior.\n * The goal is to avoid the conceptual flaws that became apparent in `Clock` over time.\n *\n * - `Timer` has an `update()` method that updates its internal state. That makes it possible to\n * call `getDelta()` and `getElapsed()` multiple times per simulation step without getting different values.\n * - The class can make use of the Page Visibility API to avoid large time delta values when the app\n * is inactive (e.g. tab switched or browser hidden).\n *\n * ```js\n * const timer = new Timer();\n * timer.connect( document ); // use Page Visibility API\n * ```\n */\nclass Timer {\n\n\t/**\n\t * Constructs a new timer.\n\t */\n\tconstructor() {\n\n\t\tthis._previousTime = 0;\n\t\tthis._currentTime = 0;\n\t\tthis._startTime = performance.now();\n\n\t\tthis._delta = 0;\n\t\tthis._elapsed = 0;\n\n\t\tthis._timescale = 1;\n\n\t\tthis._document = null;\n\t\tthis._pageVisibilityHandler = null;\n\n\t}\n\n\t/**\n\t * Connect the timer to the given document.Calling this method is not mandatory to\n\t * use the timer but enables the usage of the Page Visibility API to avoid large time\n\t * delta values.\n\t *\n\t * @param {Document} document - The document.\n\t */\n\tconnect( document ) {\n\n\t\tthis._document = document;\n\n\t\t// use Page Visibility API to avoid large time delta values\n\n\t\tif ( document.hidden !== undefined ) {\n\n\t\t\tthis._pageVisibilityHandler = handleVisibilityChange.bind( this );\n\n\t\t\tdocument.addEventListener( 'visibilitychange', this._pageVisibilityHandler, false );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disconnects the timer from the DOM and also disables the usage of the Page Visibility API.\n\t */\n\tdisconnect() {\n\n\t\tif ( this._pageVisibilityHandler !== null ) {\n\n\t\t\tthis._document.removeEventListener( 'visibilitychange', this._pageVisibilityHandler );\n\t\t\tthis._pageVisibilityHandler = null;\n\n\t\t}\n\n\t\tthis._document = null;\n\n\t}\n\n\t/**\n\t * Returns the time delta in seconds.\n\t *\n\t * @return {number} The time delta in second.\n\t */\n\tgetDelta() {\n\n\t\treturn this._delta / 1000;\n\n\t}\n\n\t/**\n\t * Returns the elapsed time in seconds.\n\t *\n\t * @return {number} The elapsed time in second.\n\t */\n\tgetElapsed() {\n\n\t\treturn this._elapsed / 1000;\n\n\t}\n\n\t/**\n\t * Returns the timescale.\n\t *\n\t * @return {number} The timescale.\n\t */\n\tgetTimescale() {\n\n\t\treturn this._timescale;\n\n\t}\n\n\t/**\n\t * Sets the given timescale which scale the time delta computation\n\t * in `update()`.\n\t *\n\t * @param {number} timescale - The timescale to set.\n\t * @return {Timer} A reference to this timer.\n\t */\n\tsetTimescale( timescale ) {\n\n\t\tthis._timescale = timescale;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Resets the time computation for the current simulation step.\n\t *\n\t * @return {Timer} A reference to this timer.\n\t */\n\treset() {\n\n\t\tthis._currentTime = performance.now() - this._startTime;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Can be used to free all internal resources. Usually called when\n\t * the timer instance isn't required anymore.\n\t */\n\tdispose() {\n\n\t\tthis.disconnect();\n\n\t}\n\n\t/**\n\t * Updates the internal state of the timer. This method should be called\n\t * once per simulation step and before you perform queries against the timer\n\t * (e.g. via `getDelta()`).\n\t *\n\t * @param {number} timestamp - The current time in milliseconds. Can be obtained\n\t * from the `requestAnimationFrame` callback argument. If not provided, the current\n\t * time will be determined with `performance.now`.\n\t * @return {Timer} A reference to this timer.\n\t */\n\tupdate( timestamp ) {\n\n\t\tif ( this._pageVisibilityHandler !== null && this._document.hidden === true ) {\n\n\t\t\tthis._delta = 0;\n\n\t\t} else {\n\n\t\t\tthis._previousTime = this._currentTime;\n\t\t\tthis._currentTime = ( timestamp !== undefined ? timestamp : performance.now() ) - this._startTime;\n\n\t\t\tthis._delta = ( this._currentTime - this._previousTime ) * this._timescale;\n\t\t\tthis._elapsed += this._delta; // _elapsed is the accumulation of all previous deltas\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction handleVisibilityChange() {\n\n\tif ( this._document.hidden === false ) this.reset();\n\n}\n\nexport { Timer };\n"],
  "mappings": ";AAcA,IAAM,QAAN,MAAY;AAAA;AAAA;AAAA;AAAA,EAKX,cAAc;AAEb,SAAK,gBAAgB;AACrB,SAAK,eAAe;AACpB,SAAK,aAAa,YAAY,IAAI;AAElC,SAAK,SAAS;AACd,SAAK,WAAW;AAEhB,SAAK,aAAa;AAElB,SAAK,YAAY;AACjB,SAAK,yBAAyB;AAAA,EAE/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,QAAS,UAAW;AAEnB,SAAK,YAAY;AAIjB,QAAK,SAAS,WAAW,QAAY;AAEpC,WAAK,yBAAyB,uBAAuB,KAAM,IAAK;AAEhE,eAAS,iBAAkB,oBAAoB,KAAK,wBAAwB,KAAM;AAAA,IAEnF;AAAA,EAED;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa;AAEZ,QAAK,KAAK,2BAA2B,MAAO;AAE3C,WAAK,UAAU,oBAAqB,oBAAoB,KAAK,sBAAuB;AACpF,WAAK,yBAAyB;AAAA,IAE/B;AAEA,SAAK,YAAY;AAAA,EAElB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW;AAEV,WAAO,KAAK,SAAS;AAAA,EAEtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa;AAEZ,WAAO,KAAK,WAAW;AAAA,EAExB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAe;AAEd,WAAO,KAAK;AAAA,EAEb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,aAAc,WAAY;AAEzB,SAAK,aAAa;AAElB,WAAO;AAAA,EAER;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ;AAEP,SAAK,eAAe,YAAY,IAAI,IAAI,KAAK;AAE7C,WAAO;AAAA,EAER;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU;AAET,SAAK,WAAW;AAAA,EAEjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,OAAQ,WAAY;AAEnB,QAAK,KAAK,2BAA2B,QAAQ,KAAK,UAAU,WAAW,MAAO;AAE7E,WAAK,SAAS;AAAA,IAEf,OAAO;AAEN,WAAK,gBAAgB,KAAK;AAC1B,WAAK,gBAAiB,cAAc,SAAY,YAAY,YAAY,IAAI,KAAM,KAAK;AAEvF,WAAK,UAAW,KAAK,eAAe,KAAK,iBAAkB,KAAK;AAChE,WAAK,YAAY,KAAK;AAAA,IAEvB;AAEA,WAAO;AAAA,EAER;AAED;AAEA,SAAS,yBAAyB;AAEjC,MAAK,KAAK,UAAU,WAAW,MAAQ,MAAK,MAAM;AAEnD;",
  "names": []
}
